<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Kubernetes on 有趣</title>
    <link>https://www.geekgame.site/categories/kubernetes/</link>
    <description>Recent content in Kubernetes on 有趣</description>
    <generator>Hugo</generator>
    <language>zh</language>
    <copyright>Copyright © 2008–2018, Steve Francia and the Hugo Authors; all rights reserved.</copyright>
    <lastBuildDate>Thu, 16 Jan 2025 10:33:42 +0800</lastBuildDate>
    <atom:link href="https://www.geekgame.site/categories/kubernetes/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>如何利用宿主机工具进行 Kubernetes Pod 网络调试</title>
      <link>https://www.geekgame.site/post/k8s/network/1/</link>
      <pubDate>Thu, 16 Jan 2025 10:33:42 +0800</pubDate>
      <guid>https://www.geekgame.site/post/k8s/network/1/</guid>
      <description>&lt;p&gt;在 Kubernetes 管理中，有时需要深入到容器的网络命名空间进行网络调试或排查问题。但如果容器内没有相关命令工具，也无法安装，则需要再宿主机进行网络调试。本文将介绍一种通过 &lt;code&gt;kubectl exec&lt;/code&gt; 命令结合 Docker 命令链来获取容器的网络命名空间的方法。&lt;/p&gt;&#xA;&lt;h4 id=&#34;步骤一获取-pod-的容器-id&#34;&gt;步骤一：获取 Pod 的容器 ID&lt;/h4&gt;&#xA;&lt;p&gt;首先，我们需要获取目标 Pod 中的容器 ID。可以通过 &lt;code&gt;kubectl&lt;/code&gt; 命令获取指定 Pod 的容器 ID。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;kubectl get pod &amp;lt;POD_NAME&amp;gt; -n &amp;lt;namespace&amp;gt; -o &lt;span class=&#34;nv&#34;&gt;jsonpath&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;{.status.containerStatuses[0].containerID}&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;&#xA;&lt;p&gt;注意：将 &lt;code&gt;&amp;lt;namespace&amp;gt;&lt;/code&gt; 替换为实际的命名空间名称，将 &lt;code&gt;&amp;lt;POD_NAME&amp;gt;&lt;/code&gt; 替换为实际的 Pod 名称。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h4 id=&#34;示例输出&#34;&gt;示例输出：&lt;/h4&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;docker://f4b8d5d882bce5c8c10a660fad5d3f5f8a82b8d5c8d87a8f193d&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;步骤二获取容器的-pid&#34;&gt;步骤二：获取容器的 PID&lt;/h4&gt;&#xA;&lt;p&gt;接下来，通过容器 ID 获取其在宿主机上的 PID。使用 &lt;code&gt;docker inspect&lt;/code&gt; 命令可以实现这一点。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Kubernetes Informer 机制</title>
      <link>https://www.geekgame.site/post/k8s/informer/</link>
      <pubDate>Wed, 17 Nov 2021 20:43:56 +0800</pubDate>
      <guid>https://www.geekgame.site/post/k8s/informer/</guid>
      <description>&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;&#xA;&lt;p&gt;Kubernetes的其他组件都是通过client-go的Informer机制与Kubernetes API Server进行通信的。&#xA;&lt;img alt=&#34;informer&#34; src=&#34;https://www.geekgame.site/k8s/informer.png&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;在Informer架构设计中,有多个核心组件,分别介绍如下。&lt;br&gt;&#xA;1.Reflector Reflector用于监控(Watch)指定的Kubernetes资源,当监控的资源发生变化时,触发相应的变更事件,例如Added(资源添加)事件、Updated(资源更新)事件、Deleted(资源删除)事件,并将其资源对象存放到本地缓存DeltaFIFO中。 &lt;br&gt;&#xA;2.DeltaFIFO DeltaFIFO可以分开理解,FIFO是一个先进先出的队列,它拥有队列操作的基本方法,例如Add、Update、Delete、List、Pop、Close等,而Delta是一个资源对象存储,它可以保存资源对象的操作类型,例如Added(添加)操作类型、Updated(更新)操作类型、Deleted(删除)操作类型、Sync(同步)操作类型等。&lt;br&gt;&#xA;3.Indexer Indexer是client-go用来存储资源对象并自带索引功能的本地存储,Reflector从DeltaFIFO中将消费出来的资源对象存储至Indexer。Indexer与Etcd集群中的数据完全保持一致。client-go可以很方便地从本地存储中读取相应的资源对象数据,而无须每次从远程Etcd集群中读取,以减轻Kubernetes API Server和Etcd集群的压力。&lt;/p&gt;&#xA;&lt;p&gt;informer 中支持处理资源的三种回掉方法:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;AddFunc :当创建资源对象时触发的事件回调方法。&lt;/li&gt;&#xA;&lt;li&gt;UpdateFunc :当更新资源对象时触发的事件回调方法。&lt;/li&gt;&#xA;&lt;li&gt;DeleteFunc :当删除资源对象时触发的事件回调方法。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;通过Informer机制可以很容易地监控我们所关心的资源事件.&lt;/p&gt;&#xA;&lt;h2 id=&#34;reflector&#34;&gt;Reflector&lt;/h2&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-golang&#34; data-lang=&#34;golang&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;NewReflector&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;lw&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ListerWatcher&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;expectedType&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;interface&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{},&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;store&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Store&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;resyncPeriod&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Duration&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Reflector&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;   &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;NewNamedReflector&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;naming&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;GetNameFromCallsite&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;internalPackages&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;lw&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;expectedType&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;store&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;resyncPeriod&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;ln&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pr</description>
    </item>
    <item>
      <title>Kubernetes 监控架构(译)</title>
      <link>https://www.geekgame.site/post/k8s/monitoring_arch/</link>
      <pubDate>Mon, 05 Jul 2021 11:09:37 +0800</pubDate>
      <guid>https://www.geekgame.site/post/k8s/monitoring_arch/</guid>
      <description>&lt;h1 id=&#34;概要&#34;&gt;概要&lt;/h1&gt;&#xA;&lt;p&gt;监控分为两个部分:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;核心监控流程由kubelet、资源评估器、metric-server(Heapster 精简版)以及API server 上的master metrics API 组成. 这些监控数据被系统核心组件使用,例如调度逻辑(调度器和基于系统指标的HPA) 和 开箱即用的UI组件(例如 kubectl top), 这条监控管道不适合与第三方监控系统集成.&lt;/li&gt;&#xA;&lt;li&gt;另一个监控流程用于从系统收集各种指标并将这些指标导出到用户端、HPA(自定义指标)以及通过适配器到处到 infrastore. 用户可以从众多的监控系统中进行选择,也可以不运行监控系统. Kubernetes 不附带监控管道, 但是第三方的选项是很容易被安装的. 我们希望第三方管道通常由每个节点的代理和一个集群级聚合器组成.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;该架构在本文档附录中的图表中进行了说明。&lt;/p&gt;&#xA;&lt;h1 id=&#34;介绍和目标&#34;&gt;介绍和目标&lt;/h1&gt;&#xA;&lt;p&gt;本文档为Kubernetes 提出了一个高级监控架构. 它涵盖了  Kubernetes Monitoring Architecture 文档中提到的一些问题. 特别关注有望满足大量需求的监控架构(组件以及组件之间的交互), 我们没有为实现这个架构指定任何特定的时间,也没有规划路线图.&lt;/p&gt;&#xA;&lt;h2 id=&#34;术语&#34;&gt;术语&lt;/h2&gt;&#xA;&lt;p&gt;有两种指标系统指标和服务指标, 系统指标是一般的指标,通常可以从每个监控的实体获得(例如容器和节点的CPU和内存使用情况). 服务指标是在应用代码明确定义并导出的(例如API服务器状态码为500的请求数量), 系统指标和服务指标都是从用户的容器或者系统基础组件获取(主节点组件,比如API服务器, 运行在主节点的插件pod, 和运行在用户节点的插件pod)&lt;/p&gt;&#xA;&lt;p&gt;我们把系统指标分为:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;核心指标 这些指标都是Kubernetes理解并用于其内部组件和核心业务的指标 — 例如, 用于调度的指标(包括用于资源评估、初始资源/垂直自动缩放,集群自动缩放, 和Pod水平自动缩放(不包括自定义指标)), Kube 仪表盘, 和 “kubectl top”, 截至目前, 这包括cpu 累计使用情况, 内存瞬时使用情况, pod 磁盘使用情况, 容器的磁盘使用情况.&lt;/li&gt;&#xA;&lt;li&gt;非核心指标，不被 Kubernetes 解读；我们通常假设它们包括核心指标（尽管不一定采用 Kubernetes 理解的格式）以及其他指标。&#xA;我们认为日志记录与监控是分开的，因此日志记录超出了本文档的范围。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;要求&#34;&gt;要求&lt;/h1&gt;&#xA;&lt;p&gt;监控架构应该是下面这个样子：&lt;/p&gt;</description>
    </item>
    <item>
      <title>kubernetes 架构</title>
      <link>https://www.geekgame.site/post/k8s/k8s/</link>
      <pubDate>Thu, 31 Oct 2019 15:26:32 +0800</pubDate>
      <guid>https://www.geekgame.site/post/k8s/k8s/</guid>
      <description>&lt;h1 id=&#34;什么是-kubernetes&#34;&gt;什么是 Kubernetes&lt;/h1&gt;&#xA;&lt;p&gt;Kubernetes(简称K8s) 是由 Google 在2014年开源的容器编排与调度管理框架，主要是为用户提供一个具有普遍意义的容器编排工具。该项目是Google内部大规模集群管理系统-Borg的一个开源版本，目前是由CNCF(Cloud Native Computing Foundation)托管项目。&#xA;Kubernetes 的主要特点：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;可扩展：Kubernetes 是高度可配置且可扩展的。&lt;/li&gt;&#xA;&lt;li&gt;可移植：Kubernetes 不限于特定平台，可以在各种公共或者私有云平台上运行。&lt;/li&gt;&#xA;&lt;li&gt;自动化：Kubernetes 是一个高度自动化的平台：可自动部署/回滚、自我修复、自动扩缩容。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h1 id=&#34;kubernetes-架构&#34;&gt;Kubernetes 架构&lt;/h1&gt;&#xA;&lt;p&gt;K8s 遵循服务器/客户端(C/S)架构,分为两部分master和node，其中master是服务端，是控制节点主要控制和管理整个K8s集群;node是客户端,是工作节点，主要处理来自于master的任务。K8s可以设置多master来实现高可用，但是默认情况下单个master 就可以完成所有的工作。&lt;br&gt;&#xA;master包含的组件有：kube-apiserver, etcd, kube-controller-manager, kube-scheduler, cloud-controller-manager; &lt;br&gt;&#xA;node 包含的组件有: kubelet, kube-proxy;&lt;br&gt;&#xA;&lt;img alt=&#34;带有两个Worker nodes和一个master的K8s架构图&#34; src=&#34;https://www.geekgame.site/k8s/Kubernetes-101-Architecture-Diagram-768x555.jpeg&#34;&gt;&#xA;&lt;a href=&#34;https://x-team.com/blog/introduction-kubernetes-architecture/&#34;&gt;图片来源&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;master-组件&#34;&gt;master 组件&lt;/h2&gt;&#xA;&lt;p&gt;kube-apiserver: 提供集群HTTP REST API, 是集群控制的唯一入口,提供访问控制、注册、信息存储功能, 同时也是集群内部模块之间数据交换的枢纽。 &lt;br&gt;&#xA;etcd:  兼具一致性和高可用性的键值数据库,保存 K8s 所有集群数据;&lt;br&gt;&#xA;kube-scheduler:  对K8s中的Pod资源进行监控调度，为Pod选择合适的工作节点； &lt;br&gt;&#xA;kube-controller-manager: K8s实现自动化的关键组件，是集群中所有资源的自动化控制中心；&lt;br&gt;&#xA;cloud-controller-manager: 云控制器管理器是指嵌入特定云的控制逻辑的控制平面组件,使得 K8s 可以直接利用云平台实现持久化卷、负载均衡、网络路由、DNS 解析以及横向扩展等功能。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
